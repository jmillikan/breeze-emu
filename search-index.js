var searchIndex = {};
searchIndex["breeze_core"] = {"doc":"","items":[[0,"dma","breeze_core","Implements DMA (Direct Memory Access).",null,null],[3,"DmaChannel","breeze_core::dma","The configuration of a DMA channel",null,null],[4,"TransferMode","","Describes how a single DMA unit (max. 4 Bytes) is transferred",null,null],[13,"Single","","Mode 0: Just reads and writes a single byte",0,null],[13,"TwoInc","","Mode 1: Transfer 2 bytes. B-Bus address is incremented for the second byte.",0,null],[13,"TwoNoInc","","Mode 2/6: Reads two bytes and writes them to the destination. B-Bus address stays the same\nfor both bytes.",0,null],[13,"FourIncOnce","","Mode 3/7: Transfer 4 bytes and increment B-Bus address after the first 2 bytes.",0,null],[13,"FourIncAlways","","Mode 4: Transfer 4 bytes and increment B-Bus address after each.",0,null],[13,"FourToggle","","Mode 5: Transfer 4 bytes, use B-Bus address offsets `0, 1, 0, 1`.",0,null],[5,"do_dma","","Performs all DMA transactions enabled by the given `channels` bitmask. Returns the number of\nmaster cycles spent.",null,{"inputs":[{"name":"peripherals"},{"name":"u8"}],"output":{"name":"u32"}}],[5,"init_hdma","","Refresh HDMA state for a new frame. This is called at V=0, H~6 and will set up some internal\nregisters for all active channels.",null,null],[5,"do_hdma","","Performs one H-Blank worth of HDMA transfers (at most 8, if all channels are enabled).",null,{"inputs":[{"name":"u8"}],"output":{"name":"u32"}}],[11,"clone","","",1,null],[11,"save_state","","",1,null],[11,"restore_state","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"load","","Load from `$43xN`, where `x` is the number of this DMA channel, and `N` is passed as\n`reg`.",1,null],[11,"store","","",1,null],[0,"record","breeze_core","Input recording and replaying",null,null],[4,"RecordingFormat","breeze_core::record","",null,null],[13,"Custom","","Custom RLE compressed format",2,null],[13,"Smv","","The SMV format used by Snes9x",2,null],[5,"create_recorder","","Create a recorder for a specified format.",null,{"inputs":[{"name":"recordingformat"},{"name":"box"},{"name":"snes"}],"output":{"name":"result"}}],[5,"create_replayer","","",null,{"inputs":[{"name":"recordingformat"},{"name":"box"},{"name":"snes"}],"output":{"name":"result"}}],[8,"WriteSeek","","Trait for recording sources",null,null],[8,"Recorder","","Trait for input recorders",null,null],[10,"new","","Create a new recorder, writing to the given writer",3,{"inputs":[{"name":"box"},{"name":"snes"}],"output":{"name":"result"}}],[10,"record_frame","","Record the state of the peripherals attached to `ports`.",3,null],[8,"Replayer","","Trait for record replayers",null,null],[10,"new","","Create a new replayer, reading from the given buffered reader.",4,{"inputs":[{"name":"box"},{"name":"snes"}],"output":{"name":"result"}}],[10,"replay_frame","","Replay the next frame, updating the state of `ports`.",4,null],[11,"fmt","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[0,"ppu","breeze_core","Emulates the Picture Processing Unit.",null,null],[17,"SCREEN_HEIGHT","breeze_core::ppu","Physical screen height\n(this is the height of a field, or a half-frame)",null,null],[17,"SCREEN_WIDTH","","Physical screen width\n(this is the width of a field, or a half-frame)",null,null],[3,"Rgb","","Standard 24-bit RGB color rendered to the frame buffer",null,null],[12,"r","","",5,null],[12,"g","","",5,null],[12,"b","","",5,null],[3,"SnesRgb","","5-bit per channel RGB value used by the SNES",null,null],[3,"Vram","","",null,null],[3,"FrameBuf","","",null,null],[3,"Ppu","","",null,null],[12,"framebuf","","PPU frame buffer. Contains raw RGB pixel data in `RGB24` format: The first byte is the red\ncomponent of the pixel in the top left corner of the frame, the second byte is the green\ncomponent and the third byte is the blue component. The fourth byte is then the red\ncomponent of the second pixel (at coordinate `(1,0)`), and so on.",6,null],[12,"oam","","Object Attribute Memory",6,null],[12,"cgram","","CGRAM - Stores the color palette",6,null],[12,"vram","","VRAM - Stores background maps and tile/character data",6,null],[12,"can_latch_counters","","Set by the emulator on writes to `$4201`: When bit 7 of `$4201` is 0, no latching can occur",6,null],[0,"cgram","","CGRAM definitions and methods",null,null],[3,"Cgram","breeze_core::ppu::cgram","",null,null],[17,"CGRAM_SIZE","","Color RAM size in Bytes",null,null],[11,"default","","",7,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",7,null],[11,"deref","","",7,null],[11,"deref_mut","","",7,null],[11,"index","","",7,null],[11,"index_mut","","",7,null],[11,"save_state","","",7,null],[11,"restore_state","","",7,null],[11,"get_color","","Looks up a color in CGRAM and returns the RGB color values stored inside, without adjusting\nthe color range to full RGB.",7,null],[11,"get_color_raw","","Gets the raw, 16-bit (technically 15), color value stored at the given color index",7,null],[11,"set_color_raw","","Set a raw color value",7,null],[11,"lookup_bg_color","breeze_core::ppu","Main entry point into the BG layer renderer.",6,null],[0,"oam","","OAM (Object Attribute Memory) representation and utilities",null,null],[3,"Oam","breeze_core::ppu::oam","",null,null],[3,"OamEntry","","Unpacked OAM entry for easier use",null,null],[12,"tile","","First tile (0-255), needs to take name table selection bit into account",8,null],[12,"name_table","","Sprite&#39;s name table (0 or 1).",8,null],[12,"x","","9 bits, considered signed (-256 - 255)",8,null],[12,"y","","",8,null],[12,"priority","","0-3",8,null],[12,"palette","","0-7. The first palette entry is `128+ppp*16`.",8,null],[12,"hflip","","",8,null],[12,"vflip","","",8,null],[12,"size_toggle","","",8,null],[17,"OAM_SIZE","","Object Attribute Memory size in Bytes",null,null],[11,"default","","",9,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",9,null],[11,"deref","","",9,null],[11,"deref_mut","","",9,null],[11,"index","","",9,null],[11,"index_mut","","",9,null],[11,"save_state","","",9,null],[11,"restore_state","","",9,null],[11,"default","","",8,{"inputs":[],"output":{"name":"oamentry"}}],[11,"clone","","",8,null],[11,"get_sprite","","Returns the OAM entry of the given sprite. Always returns a valid entry if `index` is valid\n(0...127), panics otherwise.",9,null],[11,"obj_size","breeze_core::ppu","Get the configured sprite size in pixels. If `size_toggle` is `false`, gets the size of\nsmall sprites, otherwise gets the size of large sprites (OAM size bit set).",6,null],[11,"bg_mode","","Returns the active BG mode (0-7).",6,null],[11,"render_pixel","","Main rendering entry point. Renders the current pixel and returns its color. Assumes that\nthe current pixel is on the screen.",6,null],[11,"read_chr_entry","","Reads character data for a pixel and returns the palette index stored in the bitplanes.",6,null],[11,"inidisp","","",6,null],[11,"obsel","","",6,null],[11,"bgmode","","",6,null],[11,"mosaic","","",6,null],[11,"bg1sc","","",6,null],[11,"bg2sc","","",6,null],[11,"bg3sc","","",6,null],[11,"bg4sc","","",6,null],[11,"bg12nba","","",6,null],[11,"bg34nba","","",6,null],[11,"vmain","","",6,null],[11,"m7sel","","",6,null],[11,"w12sel","","",6,null],[11,"w34sel","","",6,null],[11,"wobjsel","","",6,null],[11,"wh0","","",6,null],[11,"wh1","","",6,null],[11,"wh2","","",6,null],[11,"wh3","","",6,null],[11,"wbglog","","",6,null],[11,"wobjlog","","",6,null],[11,"tm","","",6,null],[11,"ts","","",6,null],[11,"tmw","","",6,null],[11,"tsw","","",6,null],[11,"cgwsel","","",6,null],[11,"cgadsub","","",6,null],[11,"coldata_r","","",6,null],[11,"coldata_g","","",6,null],[11,"coldata_b","","",6,null],[11,"setini","","",6,null],[11,"bg1hofs","","",6,null],[11,"m7hofs","","",6,null],[11,"bg1vofs","","",6,null],[11,"m7vofs","","",6,null],[11,"bg2hofs","","",6,null],[11,"bg2vofs","","",6,null],[11,"bg3hofs","","",6,null],[11,"bg3vofs","","",6,null],[11,"bg4hofs","","",6,null],[11,"bg4vofs","","",6,null],[11,"m7a","","",6,null],[11,"m7b","","",6,null],[11,"m7c","","",6,null],[11,"m7d","","",6,null],[11,"m7x","","",6,null],[11,"m7y","","",6,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"new","","Creates a new `SnesRgb` instance from the given RGB values.",10,{"inputs":[{"name":"u8"},{"name":"u8"},{"name":"u8"}],"output":{"name":"snesrgb"}}],[11,"r","","",10,null],[11,"g","","",10,null],[11,"b","","",10,null],[11,"saturating_add","","Performs saturating addition of `self` and `other` per color.",10,null],[11,"saturating_sub","","Performs saturating subtraction of `self` and `other` per color.",10,null],[11,"to_adjusted_rgb","","Converts 5-bit RGB to 8-bit RGB, adjusting the color space",10,null],[11,"clone","","",5,null],[11,"fmt","","",5,null],[11,"collect_sprite_data_for_scanline","","Collects visible sprites and sprite tiles for the current scanline.",6,null],[11,"maybe_draw_sprite_pixel","","Returns the value of the current pixel on the sprite layer if it has the given priority\n(and `None` otherwise).",6,null],[17,"VRAM_SIZE","","VRAM size in Bytes",null,null],[11,"default","","",11,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",11,null],[11,"deref","","",11,null],[11,"deref_mut","","",11,null],[11,"index","","",11,null],[11,"index_mut","","",11,null],[11,"save_state","","",11,null],[11,"restore_state","","",11,null],[11,"default","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",12,null],[11,"deref","","",12,null],[11,"deref_mut","","",12,null],[11,"default","","",6,{"inputs":[],"output":{"name":"ppu"}}],[11,"save_state","","",6,null],[11,"restore_state","","",6,null],[11,"load","","Load a PPU register (addresses `$2134` to `$213f`)",6,null],[11,"store","","Store a byte in a PPU register (addresses `$2100` - `$2133`)",6,null],[11,"latch_counters","","Latches the H/V counters if `$4201` bit 7 is set (otherwise, no latching can occur)",6,null],[11,"update","","Runs the PPU for a bit.",6,null],[11,"in_h_blank","","",6,null],[11,"in_v_blank","","",6,null],[11,"forced_blank","","",6,null],[11,"h_counter","","Returns the current X position",6,null],[11,"v_counter","","Returns the current Y position (scanline)",6,null],[0,"input","breeze_core","Input emulation layer",null,null],[3,"Ports","breeze_core::input","Represents the 2 controller ports on the SNES",null,null],[12,"0","","",13,null],[12,"1","","",13,null],[3,"Input","","Controller input management.",null,null],[12,"ports","","",14,null],[4,"Peripheral","","Enumeration of things that can be plugged into a controller port on the SNES.",null,null],[13,"Joypad","","The standard SNES joypad: A, B, X, Y, L, R, Start, Select, D-Pad",15,null],[12,"imp","breeze_core::input::Peripheral","The actual implementation (provided by the backend)",15,null],[12,"state","","Current joypad state. When the latch is active, this is updated by asking the backend\nfor the current state.",15,null],[11,"new_joypad","breeze_core::input","Creates a new joypad peripheral using the given `JoypadImpl`.",15,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"set_latch","","Called when the value of the lowest bit of `$4016` changes. When set to 1, the controller\nshould latch its input (whatever that means is specific to the attached peripheral).",15,null],[11,"read_bit","","Read a bit from the `Data1` and `Data2` lines. Called on serial reads either via Auto-Joypad\nmode or reads from `$4016`/`$4017`.",15,null],[11,"set_io_bit","","Sets the bit written out to the `IOBit` line.",15,null],[11,"read_io_bit","","Called on reads from `$4201` when the respective bit in `$4213` is set to 1 (if the bit in\n`$4213` is set to 0, all reads will return 0 and this method is not called).",15,null],[11,"update_hv_latch","","This will be called on every pixel. When this method returns `true`, the PPU&#39;s H/V Counters\nwill be latched.",15,null],[11,"next_frame","","Called once after every frame",15,null],[11,"default","","",13,{"inputs":[],"output":{"name":"ports"}}],[11,"index","","",13,null],[11,"index_mut","","",13,null],[11,"default","","",14,{"inputs":[],"output":{"name":"input"}}],[11,"save_state","","",14,null],[11,"restore_state","","",14,null],[11,"start_recording","","Start recording input to a `Write` implementor, often a file.",14,null],[11,"start_replay","","Start replaying input from a recording made with `start_recording`. While replaying, user\ninput is ignored (but input sources are still updated).",14,null],[11,"is_recording","","",14,null],[11,"is_replaying","","",14,null],[11,"new_frame","","",14,null],[11,"load","","Read from an input register. Updates the controller state if this is the first load in this\nframe.",14,null],[11,"store","","Store to an input register. Stores to `$4016` can change the latch line.",14,null],[11,"perform_auto_read","","Called when auto joypad read is enabled and it&#39;s time to do one.",14,null],[0,"rom","breeze_core","ROM image loading code",null,null],[3,"RomHeader","breeze_core::rom","The (decoded) SNES header",null,null],[3,"Rom","","A ROM image",null,null],[11,"clone","","",16,null],[11,"clone","","",17,null],[11,"save_state","","",17,null],[11,"restore_state","","",17,null],[11,"from_bytes","","Loads a ROM from raw data.",17,null],[11,"get_title","","",17,null],[11,"load","","",17,null],[11,"store","","",17,null],[0,"save","breeze_core","Savestate writing and reading",null,null],[4,"SaveStateFormat","breeze_core::save","Enum of supported save state formats",null,null],[13,"Zsnes","","ZSNES V0.6 (WIP)",18,null],[13,"Custom","","Custom binary format (unspecified format, subject to change)",18,null],[11,"default","","",18,{"inputs":[],"output":{"name":"self"}}],[0,"snes","breeze_core","This module glues everything together and coordinates emulation.",null,null],[3,"Wram","breeze_core::snes","",null,null],[3,"Peripherals","","Contains everything connected to the CPU via one of the two address buses. All memory accesses\nwill be directed through this.",null,null],[12,"apu","","",19,null],[12,"ppu","","",19,null],[12,"rom","","",19,null],[12,"wram","","The 128 KB of working RAM of the SNES (separate from cartridge RAM)",19,null],[12,"input","","",19,null],[12,"dma","","`$4300 - $438A`",19,null],[3,"Snes","","SNES system state",null,null],[3,"Emulator","","The emulator.",null,null],[12,"renderer","","The renderer this emulator instance uses to display the screen",20,null],[12,"audio","","The audio sink to be used for APU output",20,null],[12,"snes","","",20,null],[17,"WRAM_SIZE","","",null,null],[11,"default","","",21,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",21,null],[11,"deref","","",21,null],[11,"deref_mut","","",21,null],[11,"save_state","","",21,null],[11,"restore_state","","",21,null],[11,"save_state","","",19,null],[11,"restore_state","","",19,null],[11,"new","","",19,{"inputs":[{"name":"rom"},{"name":"input"}],"output":{"name":"peripherals"}}],[11,"load","","",19,null],[11,"store","","",19,null],[11,"save_state","","",22,null],[11,"restore_state","","",22,null],[11,"new","","",22,{"inputs":[{"name":"rom"}],"output":{"name":"self"}}],[11,"peripherals","","Get a reference to the `Peripherals` instance",22,null],[11,"peripherals_mut","","Get a mutable reference to the `Peripherals` instance",22,null],[11,"render_frame","","Runs emulation until the next frame is completed.",22,null],[11,"new","","Creates a new emulator instance from a loaded ROM and a renderer.",20,{"inputs":[{"name":"rom"},{"name":"r"},{"name":"a"}],"output":{"name":"self"}}],[11,"peripherals","","Get a reference to the `Peripherals` instance",20,null],[11,"peripherals_mut","","Get a mutable reference to the `Peripherals` instance",20,null],[11,"handle_action","","Handles a `BackendAction`. Returns `true` if the emulator should exit.",20,null],[11,"render_frame","","Runs emulation until a frame is completed, renders the frame and handles an action dictated\nby the backend.",20,null],[11,"run","","Runs the emulator in a loop",20,null],[11,"create_save_state","","Saves the current emulator state",22,null],[11,"restore_save_state","","",22,null]],"paths":[[4,"TransferMode"],[3,"DmaChannel"],[4,"RecordingFormat"],[8,"Recorder"],[8,"Replayer"],[3,"Rgb"],[3,"Ppu"],[3,"Cgram"],[3,"OamEntry"],[3,"Oam"],[3,"SnesRgb"],[3,"Vram"],[3,"FrameBuf"],[3,"Ports"],[3,"Input"],[4,"Peripheral"],[3,"RomHeader"],[3,"Rom"],[4,"SaveStateFormat"],[3,"Peripherals"],[3,"Emulator"],[3,"Wram"],[3,"Snes"]]};
searchIndex["spc700"] = {"doc":"Implements the Audio Processing Unit (APU)","items":[[3,"Spc700","spc700","The SPC700 is an 8-bit processor with a 16-bit address space.",null,null],[12,"trace","","",0,null],[11,"save_state","","",0,null],[11,"restore_state","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"store_port","","Store a byte in an IO port (`0-3`)",0,null],[11,"read_port","","Load a byte from an IO port",0,null],[11,"dispatch","","Dispatch an opcode",0,null]],"paths":[[3,"Spc700"]]};
searchIndex["wdc65816"] = {"doc":"65816 emulator (work in progress)","items":[[3,"Cpu","wdc65816","",null,null],[12,"a","","",0,null],[12,"x","","",0,null],[12,"y","","",0,null],[12,"s","","Stack pointer",0,null],[12,"dbr","","Data bank register. Bank for all memory accesses.",0,null],[12,"pbr","","Program bank register. Opcodes are fetched from this bank.",0,null],[12,"d","","Direct (page) register. Address offset for all instruction using &quot;direct addressing&quot; mode.",0,null],[12,"pc","","Program counter. Note that PBR is not changed on pc overflow, so code can not span\nmultiple banks (without `jml` or `jsr`).",0,null],[12,"trace","","",0,null],[12,"mem","","",0,null],[8,"Mem","","Trait for devices attached to the 65816&#39;s address/data bus",null,null],[10,"load","","",1,null],[10,"store","","",1,null],[11,"save_state","","",0,null],[11,"restore_state","","",0,null],[11,"new","","Creates a new CPU and executes a reset. This will fetch the RESET vector from memory and\nput the CPU in emulation mode.",0,{"inputs":[{"name":"m"}],"output":{"name":"cpu"}}],[11,"dispatch","","Executes a single opcode and returns the number of CPU clock cycles used.",0,null],[11,"trigger_nmi","","Invokes the NMI handler.",0,null],[11,"trigger_irq","","Invokes the IRQ handler if interrupts are enabled. Returns whether the interrupt was\ngenerated.",0,null]],"paths":[[3,"Cpu"],[8,"Mem"]]};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["breeze_backend"] = {"doc":"","items":[[4,"BackendAction","breeze_backend","An action that can be performed by the user, is detected by the backend and executed by the\nemulator core.",null,null],[13,"Exit","","Exit the emulator",0,null],[13,"SaveState","","Create a save state",0,null],[13,"LoadState","","Restore the last save state",0,null],[0,"input","","Input handling and traits",null,null],[0,"joypad","breeze_backend::input","The standard joypad. The most important peripheral. Can be plugged into the Multitap, but that\nisn&#39;t yet implemented or reflected here.",null,null],[3,"JoypadState","breeze_backend::input::joypad","State of a SNES joypad.",null,null],[4,"JoypadButton","","(C-like) Enum of all Joypad buttons.",null,null],[13,"A","","",1,null],[13,"B","","",1,null],[13,"X","","",1,null],[13,"Y","","",1,null],[13,"L","","",1,null],[13,"R","","",1,null],[13,"Start","","",1,null],[13,"Select","","",1,null],[13,"Up","","",1,null],[13,"Left","","",1,null],[13,"Down","","",1,null],[13,"Right","","",1,null],[8,"JoypadImpl","","Trait for joypad implementations.",null,null],[10,"update_state","","Called to &quot;latch&quot; the current joypad state.",2,null],[11,"default","","",3,{"inputs":[],"output":{"name":"joypadstate"}}],[11,"clone","","",3,null],[11,"new","","Creates a new `InputState` with no buttons pressed",3,{"inputs":[],"output":{"name":"self"}}],[11,"set","","Set a button&#39;s state",3,null],[11,"read_bit","","Reads a bit from the state, as if the state would be stored inside the joypads shift\nregister. This shifts the state to the left and inserts a 1-bit at the right side.",3,null],[0,"dummy","breeze_backend","Dummy backend that does nothing.",null,null],[3,"DummyRenderer","breeze_backend::dummy","Renderer that just does nothing, apart from saving the PPU output for later use. This allows\nusers to extract single rendered frames without having to implement `Renderer`.",null,null],[3,"DummySink","","Dummy audio sink with no output",null,null],[11,"last_frame","","",4,null],[11,"create","","",4,{"inputs":[],"output":{"name":"backendresult"}}],[11,"render","","",4,null],[11,"set_rom_title","","",4,null],[11,"create","","",5,{"inputs":[],"output":{"name":"backendresult"}}],[11,"write","","",5,null],[0,"ppu","breeze_backend","",null,null],[17,"SCREEN_WIDTH","breeze_backend::ppu","Physical screen width\n(this is the width of a field, or a half-frame)",null,null],[17,"SCREEN_HEIGHT","","Physical screen height\n(this is the height of a field, or a half-frame)",null,null],[0,"viewport","breeze_backend","Provides a utility method for calculating native viewport size when the window is resized.",null,null],[3,"Viewport","breeze_backend::viewport","A simple rectangle",null,null],[12,"x","","",6,null],[12,"y","","",6,null],[12,"w","","",6,null],[12,"h","","",6,null],[11,"for_window_size","","Calculates a viewport to use for a window of the given size.",6,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"self"}}],[6,"BackendResult","breeze_backend","Result with an erased error type.",null,null],[8,"Renderer","","Trait for screen renderers. Once per frame, they are given the raw screen data produced by the\nPPU and can then render this content in a backend-specific way.",null,null],[10,"create","","Creates a new renderer.",7,{"inputs":[],"output":{"name":"backendresult"}}],[10,"render","","Render a frame produced by the PPU. For optimal experience, the `Renderer` implementation\nshould make sure that the frame is visible as soon as possible.",7,null],[10,"set_rom_title","","Set the ROM title. This usually sets the window title.",7,null],[8,"AudioSink","","Trait for audio backends. Provides methods for writing to a stereo audio channel.",null,null],[10,"create","","Creates a new audio sink.",8,{"inputs":[],"output":{"name":"backendresult"}}],[10,"write","","Write 32 kHz 16-bit data to the device.",8,null]],"paths":[[4,"BackendAction"],[4,"JoypadButton"],[8,"JoypadImpl"],[3,"JoypadState"],[3,"DummyRenderer"],[3,"DummySink"],[3,"Viewport"],[8,"Renderer"],[8,"AudioSink"]]};
searchIndex["libsavestate"] = {"doc":"A tiny crate to help emulators implement save states.","items":[[5,"read_exact","libsavestate","Copied from `std`.",null,null],[8,"SaveState","","Trait for types which can be serialized in a save state.",null,null],[10,"save_state","","",0,null],[10,"restore_state","","",0,null],[8,"TransmuteByteSafe","","Declares that a type can be safely transmuted into a byte slice of same length as the type&#39;s\nsize in Bytes and vice-versa.",null,null],[14,"impl_save_state_fns!","","Generates the functions of the `SaveState` trait.",null,null],[14,"impl_save_state!","","Generates an impl of `SaveState` for a given type, saving/restoring a list of fields, and\nignoring a second list of fields.",null,null],[14,"impl_save_state_for_newtype!","","Generates a `SaveState` impl for a newtype wrapper. The type must be declared as\n`SomeType(InnerType)` and `InnerType` must implement `SaveState`.",null,null]],"paths":[[8,"SaveState"]]};
searchIndex["log"] = {"doc":"A lightweight logging facade.","items":[[3,"LogRecord","log","The &quot;payload&quot; of a log message.",null,null],[3,"LogMetadata","","Metadata about a log message.",null,null],[3,"LogLocation","","The location of a log message.",null,null],[3,"MaxLogLevelFilter","","A token providing read and write access to the global maximum log level\nfilter.",null,null],[3,"SetLoggerError","","The type returned by `set_logger` if `set_logger` has already been called.",null,null],[3,"ShutdownLoggerError","","The type returned by `shutdown_logger_raw` if `shutdown_logger_raw` has\nalready been called or if `set_logger_raw` has not been called yet.",null,null],[4,"LogLevel","","An enum representing the available verbosity levels of the logging framework",null,null],[13,"Error","","The &quot;error&quot; level.",0,null],[13,"Warn","","The &quot;warn&quot; level.",0,null],[13,"Info","","The &quot;info&quot; level.",0,null],[13,"Debug","","The &quot;debug&quot; level.",0,null],[13,"Trace","","The &quot;trace&quot; level.",0,null],[4,"LogLevelFilter","","An enum representing the available verbosity level filters of the logging\nframework.",null,null],[13,"Off","","A level lower than all log levels.",1,null],[13,"Error","","Corresponds to the `Error` log level.",1,null],[13,"Warn","","Corresponds to the `Warn` log level.",1,null],[13,"Info","","Corresponds to the `Info` log level.",1,null],[13,"Debug","","Corresponds to the `Debug` log level.",1,null],[13,"Trace","","Corresponds to the `Trace` log level.",1,null],[5,"max_log_level","","Returns the current maximum log level.",null,{"inputs":[],"output":{"name":"loglevelfilter"}}],[5,"set_logger","","Sets the global logger.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"set_logger_raw","","Sets the global logger from a raw pointer.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"shutdown_logger","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[5,"shutdown_logger_raw","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[8,"Log","","A trait encapsulating the operations required of a logger",null,null],[10,"enabled","","Determines if a log message with the specified metadata would be\nlogged.",2,null],[10,"log","","Logs the `LogRecord`.",2,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"max","","Returns the most verbose logging level.",0,{"inputs":[],"output":{"name":"loglevel"}}],[11,"to_log_level_filter","","Converts the `LogLevel` to the equivalent `LogLevelFilter`.",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",1,null],[11,"max","","Returns the most verbose logging level filter.",1,{"inputs":[],"output":{"name":"loglevelfilter"}}],[11,"to_log_level","","Converts `self` to the equivalent `LogLevel`.",1,null],[11,"args","","The message body.",3,null],[11,"metadata","","Metadata about the log directive.",3,null],[11,"location","","The location of the log directive.",3,null],[11,"level","","The verbosity level of the message.",3,null],[11,"target","","The name of the target of the directive.",3,null],[11,"level","","The verbosity level of the message.",4,null],[11,"target","","The name of the target of the directive.",4,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"module_path","","The module path of the message.",5,null],[11,"file","","The source file containing the message.",5,null],[11,"line","","The line containing the message.",5,null],[11,"fmt","","",6,null],[11,"get","","Gets the current maximum log level filter.",6,null],[11,"set","","Sets the maximum log level.",6,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"description","","",7,null],[11,"fmt","","",8,null],[11,"fmt","","",8,null],[11,"description","","",8,null],[14,"log!","","The standard logging macro.",null,null],[14,"error!","","Logs a message at the error level.",null,null],[14,"warn!","","Logs a message at the warn level.",null,null],[14,"info!","","Logs a message at the info level.",null,null],[14,"debug!","","Logs a message at the debug level.",null,null],[14,"trace!","","Logs a message at the trace level.",null,null],[14,"log_enabled!","","Determines if a message logged at the specified level in that module will\nbe logged.",null,null]],"paths":[[4,"LogLevel"],[4,"LogLevelFilter"],[8,"Log"],[3,"LogRecord"],[3,"LogMetadata"],[3,"LogLocation"],[3,"MaxLogLevelFilter"],[3,"SetLoggerError"],[3,"ShutdownLoggerError"]]};
searchIndex["byte_array"] = {"doc":"Utility macro for creating convenient fixed-size `u8` arrays.","items":[[14,"impl_byte_array_extra!","byte_array","hidden",null,null],[14,"impl_byte_array!","","hidden",null,null],[14,"byte_array!","","Create a newtype wrapper for `[u8; $size]` that implements `Deref`, `DerefMut` and `Default`.",null,null]],"paths":[]};
initSearch(searchIndex);
